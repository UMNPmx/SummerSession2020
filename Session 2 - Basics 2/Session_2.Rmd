---
title: "Session 2-Functions and Loops"
author: "Ya-Feng Wen & Shen Cheng"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: yes
  html_document:
    code_folding: hide
    toc: yes
    toc_float: yes
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE, results=FALSE)
```

# Objectives
+ Functions
+ Loops
    + For loops
    + Nesting
    + While loops

# Functions

### When should you write a function?
When you’ve copied and pasted a block of code more than twice! It's called the DRY ("Do not repeat yourself") principle.

### Benefits of a function

+ An evocative function name makes code easier to understand
+ Only need to update code in one place
+ Reduce incidental mistakes when copying and pasting code

### Three key steps to creating a new function:

1. Choose an evocative function name 
    + Ideally should be verbs 
    + Use snake_case or camelCase
    + Use consistent names and arguments if you have a family of functions that do similar things
    + Avoid overriding existing functions and variables
2. List the inputs, or **arguments** (should be nouns), to the function inside `function`
3. Place the code you have developed in body of the function, a `{` block that immediately follows `function(...)`

*It’s easier to start with working code and turn it into a function; it’s harder to create a function and then try to make it work.*

4. [Unit testing](http://r-pkgs.had.co.nz/tests.html) to turn informal, interactive tests into formal, automated tests

### How to write a function?

+ Basic structure: `function(arglist)  {body}`
+ One line function (drop curly braces): `function(arglist) body`. For example, `function(x) file.info(x)$isdir` to check whether path `x` is a directory or not. 
+ Using snippet. Type `fun` + <kbd>Tab</tab>


# Practice Function Writing
1. Create a function which calculate the proportion of NA values in a vector.
```{r}
# create a testing vector called test
test <- c(1:5, NA, 6:8, NA)

# check which element is NA
is.na(test)

# count the proportion of NA
as.numeric(is.na(test)) # convert Boolean to numeric 
sum(as.numeric(is.na(test))) # sum up number of NA
sum(as.numeric(is.na(test)))/length(test) # calculate the proportion

# alternatively, use the following expression to replace three lines of code above
mean(is.na(test))


prop_NA <- function(x) {
  mean(is.na(x))
}

# testing your function
prop_NA(test)
```

2. Write a function to calculate variance of a vector. 
$$Var(x) = \frac{1}{n-1}\sum_{i=1}^{n}(x_i-\bar{x})^2$$

```{r}
# number of element
length(test) # including NA 
length(na.omit(test))

# mean of the vector
mean(test) # returns NA
mean(test, na.rm = TRUE)

# mean square error
(test - mean(test, na.rm = TRUE))^2

# sum of mean square error
sum((test - mean(test, na.rm = TRUE))^2) # returns NA
sum((test - mean(test, na.rm = TRUE))^2, na.rm = T) 


variance <- function(x, na.rm=TRUE) {
  n <- length(na.omit(x))
  m <- mean(x, na.rm = na.rm)
  mean_sqaure_error <- (x - m)^2
  
  sum(mean_sqaure_error, na.rm = na.rm) / (n-1)
}


variance(test)
variance(test) == var(test, na.rm = T)  
```


3. Write a function to calculate drug concentrations until time T and plot the concentration time curve. This function allows you to calcuate drug concentrations following either the one-compartment or two-compartment PK (given as IV) with linear elimination. Recall that concentration can be described as follow: 
For One-Compartment: $$C(t) = C_{0} \times e^{-kt}$$
For Two-Compartment: $$C(t) = A e^{-\alpha t} + B e^{-\beta t}$$



```{r}
Dose = 100 # mg
Vc = 2 # L
k = 0.1 # hr-1

t = seq(0,24,1)

C0 = Dose/Vc

Conc = C0 * exp(-k*t)
#plot(Conc~t)

oneCmtIV <- function(Dose,Time) {
  # define parameters
  Vc = 2 # L
  k = 0.1 # hr-1
  # simulation time
  t = seq(0, Time, 1)
  # calculate concentration
  C0 = Dose/Vc
  Conc = C0 * exp(-k*t)
  # plot
  plot(Conc ~ t)
}

#oneCmtIV(Dose = 100, Time = 24)


twoCmtIV <- function(Dose, Time) {
  
  A = 30 # mg/L
  B = 20 # mg/L
  alpha = 1.5 # hr-1
  beta = 0.1 # hr-1
  
  t = seq(0, Time, 1)
  
  C0 = Dose/Vc
  Conc = A*exp(-alpha*t) + B*exp(-beta*t)
  
  plot(Conc ~ t)
}

#twoCmtIV(100, 24)


simulateOneTwoCmtIV <- function(Dose, Time, Cmt) {
  # parameters for 1-CMT
  Vc = 2 # L
  k = 0.1 # hr-1
  
  # parameters for 2-CMT
  A = 30 # mg/L
  B = 20 # mg/L
  alpha = 1.5 # hr-1
  beta = 0.1 # hr-1
  
  t = seq(0, Time, 0.1)
  
  C0 = Dose/Vc
  
  if (Cmt == 1) {
    
    Conc = C0 * exp(-k*t)
    
  } else if (Cmt == 2) {
    
    Conc = A*exp(-alpha*t) + B*exp(-beta*t)
    
  } else {
    
    stop("Cmt must be 1 or 2")
    
  }
  
  plot(Conc ~ t)
  
}

#simulateOneTwoCmtIV(100, 24, 1)
#simulateOneTwoCmtIV(100, 24, 2)
#simulateOneTwoCmtIV(100, 24, 3)
```

# Loops

## What is loop? 

A loop is a sequence of instructions that is repeated until a certain condition is reached. It allows you to repeat operations multiple times without copy-pasting sections of your code. 

## For Loop

### Three essential components to write a for loop
* Output
* Sequence
* Body

```{r}
#Assemble a simple dataset
test_df <- data.frame(
  v1 = c(1:5, NA, 6:8, NA), 
  v2 = seq(1,10,1),                         #seq(from, to, by)
  v3 = c(letters[1:9], NA),                 #letter() generate lower case letters
  v4 = c("apple", "banana", NA, "cherry", NA, NA, NA, "orange", NA, NA)
  )

#calculate the proportion of NA using the prop_NA function written by Jay
prop_NA(test_df$v1) 
prop_NA(test_df$v2)
prop_NA(test_df$v3)
prop_NA(test_df$v4)

#alternatively
output <- c()                         #output
for (i in 1:4){                       #sequence
  output[i] <- prop_NA(test_df[,i])   #body
}
output

#fancier
#seq_along() creates a sequence from 1 to the length of the input
#test? what other function could be used here? seq(1:ncol(test_df))/1:ncol(test_df)
#[[]] can be used for elements selection for both vector and dataframe otherwise will have to use different syntax

output <- c()
for (i in seq_along(test_df)){       
  output[[i]] <- prop_NA(test_df[[i]]) 
}
output

#add names
col_prop_NA <- c()
for (i in seq_along(test_df)){
  col_prop_NA[[i]] <- prop_NA(test_df[[i]])
  names(col_prop_NA)[i] <- names(test_df)[i]
}
col_prop_NA

#create a function
col_prop_NA <- function(df){                #name <- function(argument){}
  output <- c()                             #output
  for (i in seq_along(df)){                 #sequence
    output[[i]] <- prop_NA(df[[i]])         #body
    names(output)[i] <- names(df)[i]
  }
  output
}

col_prop_NA(test_df)

col_prop_NA(ChickWeight)

#lapply
apply(test_df, 2, prop_NA)
lapply(test_df, prop_NA)
```


### Practice for loops writting

### break and next

```{r}

output <- c()
for (i in seq_along(test_df)){
  output[[i]] <- prop_NA(test_df[[i]])
  names(output)[i] <- names(test_df)[i]
  if (i == 3) {
    break
  }
}
output

col_prop_NA <- function(df, end){
  output <- c()
  for (i in seq_along(df)){
    output[[i]] <- prop_NA(df[[i]])
    names(output)[i] <- names(df)[i]
    if (i == end) break
  }
output
}

col_prop_NA(df = test_df, end = 3)

output <- c()
for (i in seq_along(test_df)){
  if (i == 3) next
  output[[i]] <- prop_NA(test_df[[i]])
  names(output)[i] <- names(test_df)[i]
}

output <- output[!is.na(output)]    #remove column skipped
output

col_prop_NA <- function(df, skip){
  output <- c()
  for (i in seq_along(test_df)){
    if (i == skip) next
    output[[i]] <- prop_NA(test_df[[i]])
    names(output)[i] <- names(test_df)[i]
  }
  output <- output[!is.na(output)]    #remove column skipped
  output
}

col_prop_NA(df_test_df, skip = 3)


```


### nesting for loops

```{r}
#assemble another dataset

#Description: 10 patients, each patients go through 3 occasions, at each occation, 3 systolic blood pressure (SBP) measurenments are recorded
#purpose: calculate average blood pressure for each patients at each period 

#create dataset
set.seed(0720)

sbp <- data.frame(
  ID  = c(rep(1:10,9)),
  OCC = c(rep(rep(1:3,each = 10), 3)),
  SBP  = rnorm(90, mean = 130, sd = 13)
)

var <- data.frame(NULL)

for (i in sbp$ID){
  temp1 <- subset(sbp, ID == i)
  
  for (j in temp1$OCC){
    temp2 <- subset(temp1, OCC == j)
    var[i,j] = variance(temp2$SBP) 
    rownames(var)[i] = paste("ID" , i, " ")
    colnames(var)[j] = paste("OCC", j, " ")
  }
  
}

var

#questions: We have a dataset which includes 10 patients. Each patients have 3 occasions. Each occasion have 3 time points. At each time point, 3 sbp measurements are taken. 

#If you want to write a for loop to calculate the variance of sbp at each time point of each occasion for each patient. How many levels of nesting will you need? 
```


## While loop

```{r}
#purpose: write a while loop to calculate the AUC(0-t) of PK profile simulated by one compartmental model by Jay

AUC <- 0
i <- 1

while (i <= 8){
  AUC <- AUC + ((Conc[i+1] + Conc[i]) * (t[i+1] - t[i]))/2
  i = i + 1
}

paste0("AUC_0-", i-1, "=", AUC, sep=" ")

#test: write a function to compute AUC_0-t for any t specified
```

##repeat
```{r}
AUC <- 0
i <- 1

repeat{
  AUC <- AUC + ((Conc[i+1] + Conc[i]) * (t[i+1] - t[i]))/2
  if (i == 8) break
  i = i + 1
}

paste0("AUC_0-", i, "=", AUC, sep=" ")
```


# Resources: 
1. R for Data Science by Grlemund and Wickham (2017), online at <https://r4ds.had.co.nz/>
2. Advanced R by Wickham, online at <http://adv-r.had.co.nz/>